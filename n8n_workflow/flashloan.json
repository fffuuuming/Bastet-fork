{
  "name": "flashloan",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "d798e549-8950-44e4-bf1f-4f4140885454",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -784,
        -64
      ],
      "id": "60bc2748-4ce4-4360-a2da-853ce2066394",
      "name": "Webhook",
      "webhookId": "d798e549-8950-44e4-bf1f-4f4140885454"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "162cf072-03ec-49a2-b87d-820eb155c89e",
              "leftValue": "={{ $json.body.mode }}",
              "rightValue": "trace",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -560,
        -64
      ],
      "id": "c832122f-2cf4-404f-a820-43da9f5c5100",
      "name": "If"
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "={{ $execution.id }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -320,
        -176
      ],
      "id": "5fb5a7d9-d507-4696-877a-c88f89068109",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "72ea9720-b7d8-4e8c-9b6f-3a10987c34bf",
              "name": "chatInput",
              "value": "={{ $json.body.prompt }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -96,
        -48
      ],
      "id": "0dcdaf8e-08d9-48c1-9073-241dc6cfd1fc",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        192,
        -32
      ],
      "id": "dbd01027-7878-439e-b5b5-1c89a3285ff5",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "tEEn6jt3WDpqef7b",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"summary\": {\n        \"type\": \"string\",\n        \"description\": \"Brief summary of the vulnerability\"\n      },\n      \"severity\": {\n        \"type\": \"string\",\n        \"items\": {\n          \"type\": \"string\",\n          \"enum\": [\"high\", \"medium\", \"low\"]\n        },\n        \"description\": \"Severity level of the vulnerability\"\n      },\n      \"vulnerability_details\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"function_name\": {\n            \"type\": \"string\",\n            \"description\": \"Function name where the vulnerability is found\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"Detailed description of the vulnerability\"\n          }\n        },\n        \"required\": [\"function_name\", \"description\"]\n      },\n      \"code_snippet\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"string\"\n        },\n        \"description\": \"Code snippet showing the vulnerability\",\n        \"default\": []\n      },\n      \"recommendation\": {\n        \"type\": \"string\",\n        \"description\": \"Recommendation to fix the vulnerability\"\n      }\n    },\n    \"required\": [\"summary\", \"severity\", \"vulnerability_details\", \"code_snippet\", \"recommendation\"]\n  },\n  \"additionalProperties\": false\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        384,
        -32
      ],
      "id": "7b22e798-6bbb-4d74-9081-bde863d591d7",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "3cc6b065-848f-45c9-af21-974d6de59d36",
      "name": "When chat message received",
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.1,
      "position": [
        -96,
        160
      ],
      "webhookId": "471f4f97-1fd4-4312-b3ee-6fcc3310611d"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        640,
        -32
      ],
      "id": "509acd36-3a2f-49ea-b007-711980da37dc",
      "name": "Merge"
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        864,
        -32
      ],
      "id": "6bcd6cae-4821-4997-8fef-6bf42033b81b",
      "name": "Respond to Webhook1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=## Overview\n\nWhen auditing smart contracts for **Flashloan Price Manipulation** vulnerability, follow the step-by-step reasoning process for each function. The output should contain each step’s thinking.\n\n## Thinking Process\n\n1. Identify price / liquidity inputs (include but not limited):\n   - Direct sources: getReserves(), oracle.latestRoundData(), cumulativePrice, etc.\n   - Indirect sources: reserve ratios, totalSupply, totalAssets, exchangeRate/convertToAssets, market.totalLiquidity, exchangeRateStored, LP reserve-based formulas.\n   - Aggregators: list each feed and mark which feeds are AMM/reserve-based or oracle-based.\n\n2. Map impact surface:\n   - Which actions depend on these values? (borrow/mint/redeem/withdraw/swap/transfer/liquidation/tax/vote/LP pricing)\n   - Is the dependency direct (used as price) or indirect (used inside formula that affects amounts)?\n\n3. If a source is suspicious/manipulable, test exploit feasibility under a single-tx flashloan model:\n   - Specify manipulation direction (inflate / deflate / change reserve or supply).\n   - Explain how manipulating that source changes the target variable (show the formula or steps).\n   - State whether the change can occur within one transaction/block (true/false).\n   - Indicate conditions required (low-liquidity pool, specific ratio change, need to split orders, etc.).\n   - If possible, give an approximate minimal manipulation scale or describe the practical trigger (e.g., \"requires pool depth < X or swap >= Y% of reserves\"); if not quantifiable, describe qualitative conditions.\n\n4. Decide vulnerability:\n   - Vulnerable if a single flashloanable action (or single-tx sequence the attacker can perform) can manipulate price/reserves/supply to change outcomes materially.\n   - Not vulnerable if manipulation-resistant primitives (correctly used TWAP, robust Chainlink aggregation, slippage limits, multi-source majority checks over non-manipulable feeds, etc.) fully protect all dependent values.\n\n5. Remediation (brief):\n   - Recommend precise fixes: use TWAP for both price and reserve-derived metrics, prefer vetted oracles, enforce slippage/minOut, validate asset-feeds mapping, add aggregation rules that ignore zero or stale feeds, add permissioning for sensitive automated flows, or use sanity checks on liquidity/reserves.\n\n## Thinking Process — output requirement\n- Every function analysis must list the steps above (1→5) as the model's \"thinking\".\n- When an aggregator or wrong feed is detected (e.g., BTC/USD used for WBTC), the model must perform the exploit feasibility test in step 3 and report results.\n\n## Examples with Reasoning\n\n### Example 1: Vulnerable Spot Price Usage\n\nuint256 tokenPrice = IUniswapV2Pair(token0, token1).getReserves()[1];\nuint256 borrowAmount = tokenPrice * amount / 1e18;\n\nThought process:\n\n1. Identify price / liquidity inputs:\n   - Direct source: IUniswapV2Pair.getReserves() → instantaneous AMM reserves; tokenPrice is derived directly from reserves (spot).\n\n2. Map impact surface:\n   - borrowAmount uses tokenPrice directly to compute how much can be borrowed → direct dependency on instantaneous pool state affecting borrow amounts.\n\n3. Exploit feasibility under single-tx flashloan model:\n   - Manipulation direction: inflate (or deflate) the spot price by changing reserves via swaps.\n   - How manipulation changes outcome: borrowAmount = tokenPrice * amount / 1e18, so borrowAmount scales linearly with tokenPrice. Increasing tokenPrice by X% increases borrowAmount by X%.\n   - Can this be done in a single transaction/block? true — attacker can perform swaps or flashloan-driven trades within the same tx to change reserves before the read.\n   - Conditions required: requires moving a non-trivial portion of pool reserves (i.e., low liquidity or large flashloan relative to reserves). Exact minimal scale depends on pool depth and AMM curve; not directly quantifiable from snippet without pool reserves.\n\n4. Decide vulnerability:\n   - Vulnerable: instantaneous reserve-based price is used directly for borrowing and can be manipulated within one tx.\n\n5. Remediation (brief):\n   - Use TWAP / manipulation-resistant oracle for price reads, add sanity checks on reserve/supply changes, enforce slippage/minOut limits, or require aggregated non-manipulable feeds.\n\n4. Vulnerability confirmed: borrowing amount can be exploited.\n\nConclusion: Contains vulnerability\n\n### Example 2: Vulnerable Pool Swap Dependency\n\nfunction executeTrade(uint256 amount) external {\n    uint256 price = IUniswapV3Pool(pool).slot0().sqrtPriceX96;\n    uint256 output = calculateOutput(amount, price);\n    token.transfer(msg.sender, output);\n}\n\nThought process:\n\n1. Identify price / liquidity inputs:\n   - Direct source: IUniswapV3Pool.slot0().sqrtPriceX96 → current instantaneous pool price (v3 slot0).\n\n2. Map impact surface:\n   - output is calculated from amount and instantaneous price → the function’s transfer amount depends directly on the pool’s current on-chain price.\n\n3. Exploit feasibility under single-tx flashloan model:\n   - Manipulation direction: inflate or deflate slot0 price by executing swaps that shift the pool’s sqrtPrice (within tick liquidity constraints).\n   - How manipulation changes outcome: calculateOutput(amount, price) will return larger/smaller output proportional to price change; attacker-controlled change in slot0 directly changes tokens transferred out.\n   - Can this be done in a single transaction/block? true — a flashloan + targeted swaps can move v3 price within one transaction (subject to liquidity/tick ranges).\n   - Conditions required: must be able to move price enough given v3 tick depth; may require large capital or low-liquidity ticks; splitting trades in the same tx can be used if contract allows multiple swaps in one tx.\n\n4. Decide vulnerability:\n   - Vulnerable: uses instantaneous slot0 price without manipulation-resistant protection.\n\n5. Remediation (brief):\n   - Use TWAP/observations over time, require slippage safeguards, prefer vetted oracle feeds, validate expected price ranges before transfer.\n\n4. Vulnerability confirmed.\n\nConclusion: Contains vulnerability\n\n### Example 3:\n\n    mapping(address => Observation) public pairObservations;\n\n    function update(address pairAddress) external {\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) =\n            IUniswapV2Pair(pairAddress).price0CumulativeLast();\n\n        pairObservations[pairAddress] = Observation({\n            blockTimestamp: blockTimestamp,\n            price0Cumulative: price0Cumulative,\n            price1Cumulative: price1Cumulative\n        });\n    }\n\n    function consult(address pairAddress, uint256 amountIn, address tokenIn)\n        external view returns (uint256 amountOut) {\n        Observation memory lastObservation = pairObservations[pairAddress];\n        require(lastObservation.blockTimestamp > 0, \"Oracle not initialized\");\n\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) =\n            IUniswapV2Pair(pairAddress).price0CumulativeLast();\n\n        uint32 timeElapsed = blockTimestamp - lastObservation.blockTimestamp;\n        require(timeElapsed > 0, \"Oracle update required\");\n\n        uint256 price0Average = (price0Cumulative - lastObservation.price0Cumulative) / timeElapsed;\n        uint256 price1Average = (price1Cumulative - lastObservation.price1Cumulative) / timeElapsed;\n\n        address token0 = IUniswapV2Pair(pairAddress).token0();\n\n        if (tokenIn == token0) {\n            amountOut = (amountIn * price0Average) / price1Average;\n        } else {\n            amountOut = (amountIn * price1Average) / price0Average;\n        }\n    }\n}\n\n\nThought process:\n\n1. Identify price / liquidity inputs:\n   - Sources: price0CumulativeLast() (cumulative price) stored as an observation with a timestamp → TWAP computed from cumulative difference / timeElapsed.\n\n2. Map impact surface:\n   - consult() uses time-weighted average prices to compute amountOut → dependent on historical cumulative price difference, not instantaneous spot.\n\n3. Exploit feasibility under single-tx flashloan model:\n   - Manipulation direction: attacker would need to change cumulative price over the observation window; a single-transaction instantaneous swap only changes instantaneous reserves and has limited effect on the cumulative integral.\n   - How manipulation changes outcome: priceAverage = (priceCumulative_now - priceCumulative_then) / timeElapsed. To materially skew the average in a single tx, the attacker must either:\n     - Manipulate during a long window repeatedly (not single tx), or\n     - Control both observed timestamps/observations (e.g., if update() and observation timing are attacker-controlled and the window is tiny).\n   - Can this be done in a single transaction/block? false in the normal secure setup — single-tx flashloan cannot meaningfully alter TWAP computed over a non-trivial timeElapsed. However, if timeElapsed is very small (or if the contract allows attacker-controlled rapid update() calls that set observations with tiny windows), then manipulation may become feasible.\n   - Conditions required for attack: attacker must control both observations or the TWAP window must be too short / update() usage flawed.\n\n4. Decide vulnerability:\n   - Not vulnerable in the typical correct TWAP usage (time-weighted average prevents single-tx manipulation).\n   - Caveat: if observation windows are too short or update() is insecurely called such that attacker can set both endpoints, vulnerability may exist.\n\n5. Remediation (brief):\n   - Ensure TWAP window is sufficiently long, protect update() cadence (e.g., only allow trusted keeper or require minimum timeElapsed), add checks that reject unusually small timeElapsed windows.\n\n4. Conclusion: TWAP ensures that a flashloan cannot manipulate the price instantly.\n\nConclusion: No vulnerability\n\n\n\n## Report Format\n\nIf the input is not a cryptocurrency smart contracts, report with a empty array:\n\n\n[]\n\n\nIf the conclusion of a function is “No vulnerability”, report with a empty array:\n\n\n[]\n\n\nIf vulnerabilities found in a function, report with a json:\n\n\n[\n    {\n        \"Summary\":  \"summary of the vulnerabilities\",\n        \"Vulnerability Details\": {\n            \"File Name\": \"Name of the file\",\n            \"Function Name\": \"Name of the function\",\n            \"Description\": \"a brief description of the vulnerability\"\n        },\n    \n        \"Code Snippet\": [\n            \"code snippet in the file\"\n        ],\n    \n        \"Recommendation\": \"recommendation of how to fix the vulnerability\"\n    \n    }\n]\n"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        192,
        -272
      ],
      "id": "eb58ffd0-2e36-4f9b-aba8-7ce62b105cfb",
      "name": "COT - flashloan price manipulation attack",
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=### Overview\n\nYou are a smart contract security auditor. After reading the following knowledge about flashloan vote manipulation vulnerability, follow the thinking process to detect the problem in the contract code.\n\n### Core Principle\n\nGovernance must be resistant to artificial inflation of voting power.\nAny model where voting weight depends on current token balance, LP position value, or live oracle reading becomes exploitable through:\n- Flash loans\n- Just-in-time staking\n- Reserve manipulation\n- Delegation/transfer tricks within a single block\nThus, voting power must be tied to historical state, temporal commitment, or protected by strict eligibility\n\n### General Pattern\n\nA robust design incorporates one or more of the following categories:\n1. Historical or Time-Averaged Voting Power\n    - Use getPastVotes() or block-based snapshots at proposal creation.\n    - Use lock-based or ve-style models reflecting amount × time.\n2. Flash-Loan / Atomicity Defenses\n    - Activation delay: Newly acquired tokens or deposits cannot vote immediately.\n    - Withdrawal delay: Users cannot deposit → vote → withdraw in the same block.\n    - Same-block freeze: Balance changes within the same block yield zero voting power.\n3. Valuation-Based Safety\n    - If voting depends on LP ratios or oracle prices, use:\n        - TWAP\n\t\t\t\t- Max per-user caps\n\t\t\t\t- Reserve sanity checks\n\t\t\t\t- Anti-manipulation guards against thin liquidity\n\n### Thinking Process\n\n1. **Identify potential targets**\n\n   Search for governance-related entrypoints:\n\n   - Proposal lifecycle:\n     - `propose`, `queue`, `execute`, `cancel`.\n   - Voting actions:\n     - `castVote`, `castVoteWithReason`, `vote`, `voteFor`, `delegate`, `delegateBySig`.\n   - View functions:\n     - `getVotes`, `getPastVotes`, `votingPower`, `getVotingPower`, `quorum`, `countVotes`, `tally`.\n\n2. **Extract the voting model**\n\n   Goal: precisely answer: **“How is voting power computed at tally time?”**\n\n   **Locate calculation sites**\n\n   - Tallying:\n     - `countVotes`, `tally`, `state`, `execute`.\n   - View helpers:\n     - `getVotesFor`, `getVotingPower`, `getVotes`.\n\n   **Identify formulas and data sources**\n\n   Common patterns:\n\n   - **Direct token balance**\n     - `balanceOf(voter)` or `token.balanceOf(voter)`.\n\n   - **Vault / gauge mapping**\n     - `votingWeight[voter]`, `userInfo[voter].amount`, `member_weight[addr]`.\n\n   - **ve-style (lock-based)**\n     - `Point { bias, slope }`, `locked.amount`, `locked.end`.\n     - Functions like `balanceOfNFTAt(tokenId, block)` or `getPastVotes`.\n\n   - **Valuation-based**\n     - Formulas using LP / pool state:\n       - `LP.balanceOf(voter)`, `LP.totalSupply()`\n       - Pool reserves `reserve0`, `reserve1`\n       - Oracle prices (Chainlink, TWAPs, on-chain or off-chain).\n\n3. **Check protection primitives**\n\n   3.1 **Voting power model**\n\n   - **Snapshot at proposal creation or voting start**\n\n     Expect structures like:\n\n     - `votingPowerSnapshot[proposalId][voter]`\n     - `proposal.snapshotBlock`\n\n     Tallying should use:\n\n     - `getPastVotes(voter, snapshotBlock)` or stored snapshot values.\n\n     Red flag:\n\n     - Reading live balances in `tally` or `getVotes` used for counting.\n\n   - **Time-weighted or lock-weighted power**\n\n     Power reflects amount × duration, not just instantaneous balance:\n\n     - Voting power increases with longer lock or staking duration.\n     - Early withdrawals reduce or zero out power.\n\n     Red flag:\n\n     - Pure `balanceOf(voter)` with no minimum duration, no lock.\n\n   3.2 **Flash-loan defenses**\n\n   - **Same-block filter**\n\n     If a token / NFT was received or balance changed in the current block, voting power should be 0:\n\n     ```solidity\n     if (ownershipChange[tokenId] == block.number) return 0;\n     ```\n\n     Or similar for ERC20 balances (last transfer block check).\n\n   - **Eligibility delay**\n\n     Recently increased stake or locked amount becomes vote-eligible only after `minDelay` blocks or `minDelaySeconds`:\n\n     ```solidity\n     require(\n         block.number >= depositBlock[user] + minDelay,\n         \"Not yet vote-eligible\"\n     );\n     ```\n\n     Red flag:\n\n     - Immediate eligibility upon deposit, with no delay.\n\n   - **Atomic enter → vote → exit prevention**\n\n     Withdrawals or unlocks are restricted immediately after power-increasing actions:\n\n     - Lockup for at least one block or until the end of voting window / epoch.\n\n     Red flag:\n\n     - User can `deposit → castVote → withdraw` in the same tx or block, with no cost.\n\n   3.3 **Live-state avoidance**\n\n   Voting power should not be derived from:\n\n   - Live LP ratios or pool reserves during the active proposal.\n   - Spot prices from manipulable oracles.\n\n   Prefer:\n\n   - Snapshotted pool state at proposal creation.\n   - TWAP oracles for valuation.\n\n4. **Exploit feasibility analysis (single-tx / single-block)**\n\n   If none of the above protections are present and the model is manipulable:\n\n   - **Explain the manipulation channel**\n\n     Show how the attacker can inflate voting power:\n\n     - Example: `votingPower = token.balanceOf(attacker)` and token is flash-loanable.\n     - Example: `votingPower = LP.balanceOf(attacker) * pricePerLP` with price derived from manipulable pool state.\n\n   - **Check if it fits in a single tx / block**\n\n     Explicitly reason about:\n\n     - `flashLoan → deposit / lock → vote / propose → withdraw → repay` within one transaction.\n     - Same-block execution with no snapshot, no delay.\n\n   - **Conclude clearly**\n\n     - “Yes, fully doable within one tx” or\n     - “No, requires multi-block exposure / lock”.\n\n5. **Remediation (vote manipulation)**\n\n   Provide precise, concrete fixes:\n\n   - Introduce snapshots and use `getPastVotes` or equivalent at `snapshotBlock`.\n   - Add eligibility delay for new deposits / locks before they count towards voting.\n   - Enforce exit lock (no immediate withdrawal after increasing power).\n   - Replace spot price / live reserves with TWAP or snapshotted values at proposal creation.\n   - Add same-block filters for voting power on newly received tokens / NFTs.\n\n### Example 1: Vulnerable Spot Price Usage\n\n```solidity\nuint256 tokenPrice = IUniswapV2Pair(token0, token1).getReserves()[1];\nuint256 borrowAmount = tokenPrice * amount / 1e18;\n```\n\nThought process:\n\n\n### Report Format\n\nIf the input is not a cryptocurrency smart contracts, report with a empty array:\n\n\n[]\n\n\nIf the conclusion of a function is “No vulnerability”, report with a empty array:\n\n\n[]\n\n\nIf vulnerabilities found in a function, report with a json:\n\n\n[\n    {\n        \"Summary\":  \"summary of the vulnerabilities\",\n        \"Vulnerability Details\": {\n            \"File Name\": \"Name of the file\",\n            \"Function Name\": \"Name of the function\",\n            \"Description\": \"a brief description of the vulnerability\"\n        },\n    \n        \"Code Snippet\": [\n            \"code snippet in the file\"\n        ],\n    \n        \"Recommendation\": \"recommendation of how to fix the vulnerability\"\n    \n    }\n]"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        192,
        144
      ],
      "id": "000e74b4-5134-4362-a20a-ddbe2d8ae651",
      "name": "COT - flashloan vote manipulation attack",
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=### Overview\n\nYou are a smart contract security auditor. After reading the following knowledge about flashloan reward manipulation vulnerability, follow the thinking process to detect the problem in the contract code.\n\n### Core Principle\n\nReward allocation must reflect **continuous stake commitment**, not instantaneous capital.  \nIf rewards depend solely on the current balance at claim time or at a single update tick, flash loans or short-term liquidity bursts can artificially boost the reward share.\n\nTherefore, reward calculation must depend on **time in stake**, **historical state**, or require **multi-block exposure**.\n\n### General Pattern\n\nA secure reward model applies at least one of:\n1. Time-Dependent Reward Weighting\n    - Rewards accrue as: `userReward += userBalance * timeDelta * rewardRate / totalSupply`\n    - Depositing shortly before claiming yields negligible benefits\n2. Flash-Loan / Atomicity Protection\n    - Minimum stake duration before any reward eligibility.\n    - Exit lock: Users cannot deposit and immediately withdraw while still collecting rewards.\n    - Same-block veto: Staking actions within the same block do not contribute to reward weight.\n3. Derived-Value Protection (LP / Oracle Based)\n    - When rewards depend on position value (LP shares, derivative tokens, oracle prices):\n\t\t    - Use TWAP\n\t\t    - Enforce reserve sanity checks\n\t\t    - Cap the reward weight per unit of LP\n\t\t    \n### Thinking Process\n\n1. **Identify reward-related targets**\n\n   Search for all functions that interact with the reward system.\n\n   - **Accrue or update rewards:**\n     - `updatePool`, `updateRewards`, `accumulateRewards`, `onDeposit`, `onWithdraw`.\n\n   - **Distribute or settle rewards:**\n     - `claim`, `getReward`, `harvest`, `withdrawAndHarvest`, `exit`.\n\n   - **Adjust positions affecting reward weight:**\n     - `deposit`, `stake`, `bond`, `lock`, `increaseAmount`, `addLiquidity`.\n\n   - **View functions that compute pending rewards:**\n     - `earned(user)`, `pendingReward(user)`, `claimable(user)`.\n\n2. **Extract the reward model**\n\n   Goal: precisely answer: **“How is a user’s reward per epoch / per distribution computed?”**\n\n   **Locate the core formula**\n\n   Typical patterns:\n\n   - **Share-based:**\n     ```solidity\n     userReward = userShare * accRewardPerShare - rewardDebt;\n     ```\n\n   - **Proportional to balance:**\n     ```solidity\n     userReward = userBalance * rewardRate * timeDelta / totalBalance;\n     ```\n\n   - **Boosted / ve-based:**\n     - Combination of `stakeAmount` and `vePower`, e.g. Curve-style boosts.\n\n   - **Value-based (LP / asset-value based):**\n     - Reward weight derived from LP or position value:\n       ```solidity\n       positionValue = amount * price; // or derived from reserves / oracles\n       ```\n\n   **Identify state variables and inputs**\n\n   - **Per-pool accumulators:**\n     - `accRewardPerShare`, `rewardPerTokenStored`, `lastUpdateTime`, `rewardRate`.\n\n   - **Per-user data:**\n     - `amount`, `rewardDebt`, `userRewardPerTokenPaid`, `rewards`, `lastActionTime`.\n\n   - **External sources:**\n     - Oracle prices, pool reserves, LP `totalSupply`, and similar valuation inputs.\n\n   **Determine when “weight” is read**\n\n   - At accrual time (e.g. inside `deposit`, `withdraw`, `claim`).\n   - At period boundaries (e.g. epoch end, explicit snapshot).\n   - In on-the-fly view functions (e.g. `earned(user)` reading live balances).\n\n   **Red flag:**\n   - Reward share is computed **strictly from current balance** at claim time or a single on-chain update, with **no time component**.\n\n3. **Check protection primitives (rewards)**\n\n   3.1 **Time and lock-based protection**\n\n   - **Time-weighted accrual**\n\n     Rewards scale with time in stake:\n\n     ```solidity\n     rewards += userBalance\n         * (lastTimeRewardApplicable() - lastUpdateTime)\n         * rewardRate\n         / totalSupply;\n     ```\n\n     - A user staking just before claim should receive ~0 for the previous interval.\n\n   - **Minimum stake / lock duration**\n\n     User must satisfy a minimum duration before full reward eligibility:\n\n     ```solidity\n     require(\n         block.timestamp >= stakeTime[user] + minStakeDuration,\n         \"Not yet reward-eligible\"\n     );\n     ```\n\n     - This can gate:\n       - When `claim` is allowed, or\n       - When full reward share is applied.\n\n     **Red flag:**\n     - No minimum duration; user gets immediate full participation in rewards.\n\n   - **Cliff or vesting**\n\n     - Rewards vest over time.\n     - Short-term users receive reduced or zero rewards if they exit early.\n\n   3.2 **Snapshot-based or epoch-based rewards**\n\n   - **Epoch snapshots**\n\n     Reward weights are based on user balances at a defined point:\n\n     - Epoch start or a snapshot block.\n     - Use patterns like:\n       - `balanceOfAt(user, epochSnapshotBlock)`.\n\n     **Red flag:**\n     - Reward distribution uses **live balances** at distribution block with no historical snapshot.\n\n   - **Guarding against “just-in-time” deposits**\n\n     - If distribution uses snapshot at time `T`, deposits after `T` must not count for that epoch’s rewards.\n     - Check logic that explicitly excludes late joiners for the current reward period.\n\n   3.3 **Flash-loan-specific defenses (rewards)**\n\n   - **Same-block / same-tx filters**\n\n     If deposit and withdrawal happen in the same block / transaction:\n\n     - Either rewards for that block are zero, or\n     - The position is treated as not staked for reward purposes.\n\n     Look for patterns such as:\n\n     ```solidity\n     require(stakeBlock[user] < block.number, \"Same-block stake not eligible\");\n     ```\n\n   - **Entry → accrue → exit atomicity**\n\n     Check feasibility of a single-tx path:\n\n     - `flashLoan → deposit/stake → trigger reward update/distribution → withdraw → repay`.\n\n     **Defenses:**\n\n     - Reward updates ignore positions opened in the same block.\n     - Withdrawals in the same block lose eligibility for that period’s rewards.\n\n   - **Valuation sanity checks (for LP / oracle-based weights)**\n\n     If reward weight uses LP value or oracle prices:\n\n     - Use **TWAP** instead of spot.\n     - Enforce reserve sanity checks.\n     - Cap reward weight per LP share / per user.\n\n     **Red flag:**\n     - `weight = amount * spotPrice()` where `spotPrice` is derived from a manipulable pool with no TWAP or safeguards.\n\n4. **Exploit feasibility under single-tx flash-loan model**\n\n   If protections are missing or weak:\n\n   - **Construct the attack path**\n\n     Clearly show:\n\n     - Where attacker’s balance / position enters the reward formula.\n     - How a flash-loaned amount increases `userShare` or `userBalance`.\n\n     Example flow:\n\n     1. Flash-loan asset `A`.\n     2. Stake / add liquidity into reward contract.\n     3. Call function that updates `accRewardPerShare` or triggers distribution.\n     4. Claim rewards.\n     5. Unstake / remove liquidity.\n     6. Repay flash loan.\n\n   - **Check whether all steps fit in one tx / block**\n\n     Confirm there is no:\n\n     - Required multi-block delay.\n     - Required epoch crossover.\n     - Lock preventing immediate exit.\n\n   - **Conclude explicitly**\n\n     - “Yes, full reward extraction is feasible in one transaction with negligible capital at risk.”\n     - Or: “No, exploit requires multi-block exposure; not a pure flash-loan issue (but may still be a short-term farming issue).”\n\n   - **Quantify the impact**\n\n     Estimate:\n\n     - Additional reward captured by attacker relative to honest users.\n     - Whether the attacker can repeatedly execute the attack per distribution.\n     - Whether this can drain or significantly deplete the reward pool.\n\n5. **Remediation (reward manipulation)**\n\n   Provide concrete, minimal-change fixes:\n\n   - Introduce **time-weighted accrual** or **epoch snapshots**:\n     - Rewards for epoch `N` use balances at snapshot `S`, not live balances.\n\n   - Add **minimum stake duration** before a position participates fully in rewards.\n\n   - Prevent same-tx / same-block `deposit → claim → withdraw` patterns:\n     - Apply per-block restrictions or reset reward eligibility on withdraw.\n\n   - Replace **spot price / live reserves** with:\n     - TWAP-based pricing, or\n     - Capped valuation for reward weight.\n\n   - Where feasible, reuse the same protections as in governance:\n     - Snapshots, lockups, same-block filters.\n     - This keeps the system consistent and easier to reason about.\n\n\n\n\n\n\n## Report Format\n\nIf the input is not a cryptocurrency smart contracts, report with a empty array:\n\n\n[]\n\n\nIf the conclusion of a function is “No vulnerability”, report with a empty array:\n\n\n[]\n\n\nIf vulnerabilities found in a function, report with a json:\n\n\n[\n    {\n        \"Summary\":  \"summary of the vulnerabilities\",\n        \"Vulnerability Details\": {\n            \"File Name\": \"Name of the file\",\n            \"Function Name\": \"Name of the function\",\n            \"Description\": \"a brief description of the vulnerability\"\n        },\n    \n        \"Code Snippet\": [\n            \"code snippet in the file\"\n        ],\n    \n        \"Recommendation\": \"recommendation of how to fix the vulnerability\"\n    \n    }\n]\n\n"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        208,
        320
      ],
      "id": "84dbcb31-b0c7-4814-9093-fdc32c939da0",
      "name": "COT - flashloan reward manipulation attack",
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Respond to Webhook": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "COT - flashloan price manipulation attack",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "COT - flashloan vote manipulation attack",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "COT - flashloan reward manipulation attack",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "COT - flashloan price manipulation attack",
            "type": "ai_outputParser",
            "index": 0
          },
          {
            "node": "COT - flashloan vote manipulation attack",
            "type": "ai_outputParser",
            "index": 0
          },
          {
            "node": "COT - flashloan reward manipulation attack",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "COT - flashloan price manipulation attack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When chat message received": {
      "main": [
        [
          {
            "node": "COT - flashloan price manipulation attack",
            "type": "main",
            "index": 0
          },
          {
            "node": "COT - flashloan vote manipulation attack",
            "type": "main",
            "index": 0
          },
          {
            "node": "COT - flashloan reward manipulation attack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Respond to Webhook1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "COT - flashloan price manipulation attack": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "COT - flashloan vote manipulation attack": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "COT - flashloan reward manipulation attack": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 2
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "7c8cb380-d126-4fe1-87d4-95757cfe06a0",
  "meta": {
    "instanceId": "4a069146204bb94ad0f34441729eed3339b62949be5e1b6286f0403fac9092a4"
  },
  "id": "zlUBwG4xuIooLKgg",
  "tags": []
}